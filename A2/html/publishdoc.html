
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ELEC 4700 Assignment 2 - Finite Difference Method</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-02-21"><meta name="DC.source" content="publishdoc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ELEC 4700 Assignment 2 - Finite Difference Method</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">1a - 1D Electrostatic Potential</a></li><li><a href="#2">1b - 2D Electrostatic Potential (Finite Difference Method)</a></li><li><a href="#3">1b - 2D Electrostatic Potential (Analytic Method)</a></li><li><a href="#4">1b - Discussion</a></li><li><a href="#5">2 - Non-Uniform Conductivity Map</a></li></ul></div><h2 id="1">1a - 1D Electrostatic Potential</h2><p>Below is a solution to the 2D potential, but represented as a 3D surface with a constant potential in the y direction. One side of the rectangle is held at a potential of 1, the other side is held at 0, and dV/dy is set to 0 for the other two sides to allow for the flat 1D-like potential.</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

L = 100;
W = 3/2*L;
Vo = 1;

G = sparse(L*W,L*W);
B = zeros(1,L*W);

<span class="keyword">for</span> i=1:L
    <span class="keyword">for</span> j=1:W
        n = j + (i-1)*W;

        <span class="keyword">if</span> i==L
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        <span class="keyword">elseif</span> i==1
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">elseif</span> j==1
            G(n,:) = 0;
            G(n,n) = -1;
            G(n,n+1) = 1;     <span class="comment">% dV/dy = 0</span>
        <span class="keyword">elseif</span> j==W
            G(n,:) = 0;
            G(n,n) = -1;
            G(n,n-1) = 1;     <span class="comment">% dV/dy = 0</span>
        <span class="keyword">else</span>
            G(n,:) = 0;
            G(n,n) = -4;
            G(n,n-1) = 1;
            G(n,n+1) = 1;
            G(n,n-W) = 1;
            G(n,n+W) = 1;
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

spy(G);

F=G\B';

Vmap = zeros(L,W);

<span class="keyword">for</span> i=1:L
    <span class="keyword">for</span> j=1:W
        n = j + (i-1)*W;
        Vmap(i,j) = F(n);
    <span class="keyword">end</span>
<span class="keyword">end</span>


surf(Vmap);
pause(0.001);
</pre><img vspace="5" hspace="5" src="publishdoc_01.png" alt=""> <h2 id="2">1b - 2D Electrostatic Potential (Finite Difference Method)</h2><p>Below is the solution to the potential system where instead of having dV/dy = 0 for the last two sides, they are instead fixed at 0.</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

W = 100;
L = 3/2*W;
Vo = 1;

G = sparse(L*W,L*W);
B = zeros(1,L*W);

<span class="keyword">for</span> i=1:L
    <span class="keyword">for</span> j=1:W
        n = j + (i-1)*W;

        <span class="keyword">if</span> i==1 || i==L
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        <span class="keyword">elseif</span> j==1
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">elseif</span> j==W
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">else</span>
            G(n,:) = 0;
            G(n,n) = -4;
            G(n,n-1) = 1;
            G(n,n+1) = 1;
            G(n,n-W) = 1;
            G(n,n+W) = 1;
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

F=G\B';

Vmap = zeros(L,W);

<span class="keyword">for</span> i=1:L
    <span class="keyword">for</span> j=1:W
        n = j + (i-1)*W;
        Vmap(i,j) = F(n);
    <span class="keyword">end</span>
<span class="keyword">end</span>

surf(Vmap);
pause(0.001);
</pre><img vspace="5" hspace="5" src="publishdoc_02.png" alt=""> <h2 id="3">1b - 2D Electrostatic Potential (Analytic Method)</h2><p>Below is the same potential system as before, but solved using the analytic solution provided by the lab document.</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

W = 100;
L = 3/2*W;
Vo = 1;
Terms = 60;

V = zeros(L+1,W);

<span class="keyword">for</span> k=1:Terms
    <span class="keyword">for</span> j=1:W
        <span class="keyword">for</span> i=1:L+1
            V(i,j) = V(i,j) + 4*Vo/pi*1/(2*k-1)*cosh((2*k-1)*pi*(i-L/2-1)/W)/cosh((2*k-1)*pi*(L/2)/W)*sin((2*k-1)*pi*j/W);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    surf(V);
    pause(0.05);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="publishdoc_03.png" alt=""> <h2 id="4">1b - Discussion</h2><p>60 terms were used for the analytic series solution method, as it was determined that using larger values of the index n resulted in an inf/inf calculation, resulting in a NaN output from Matlab. Both the analytic and finite difference methods produced approximately the same potential distributions. One of the downsides of the finite difference method is the rough edges on the corners of the map, which the analytic method seemed not to have. However, the analytic method experiences the Gibbs phenomenon due to the termination of the series solution, resulting in overshoots of the solution at the map boundaries.</p><h2 id="5">2 - Non-Uniform Conductivity Map</h2><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

L = 100;
W = 3/2*L;
Lb = round(L/3);
Wb = round(W/3);
Vo = 1;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

<span class="keyword">for</span> i=1:Wb
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i=round(W-Wb):W
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(1)
hold <span class="string">on</span>
surf(Sigma);
axis([0 L 0 W])
hold <span class="string">off</span>

G = sparse(L*W,L*W);
B = zeros(1,L*W);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;

        <span class="keyword">if</span> i==1 &amp;&amp; j==L/2
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        <span class="keyword">elseif</span> i==W &amp;&amp; j==L/2
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j-1));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+L) = 1/Sigma(i+1,j);
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i-1,j) + 1/Sigma(i,j+1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n-L) = 1/Sigma(i-1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i-1,j) + 1/Sigma(i,j-1));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n-L) = 1/Sigma(i-1,j);
        <span class="keyword">elseif</span> j==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1) + <span class="keyword">...</span>
                1/Sigma(i-1,j));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j);
            G(n,n-L) = 1/Sigma(i-1,j);
        <span class="keyword">elseif</span> j==L
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j-1) + <span class="keyword">...</span>
                1/Sigma(i-1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+L) = 1/Sigma(i+1,j);
            G(n,n-L) = 1/Sigma(i-1,j);
        <span class="keyword">elseif</span> i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1) + <span class="keyword">...</span>
                1/Sigma(i,j-1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j);
            G(n,n-1) = 1/Sigma(i,j-1);
        <span class="keyword">elseif</span> i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i,j+1) + 1/Sigma(i,j-1) + <span class="keyword">...</span>
                1/Sigma(i-1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n-L) = 1/Sigma(i-1,j);
        <span class="keyword">else</span>
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i,j+1) + 1/Sigma(i,j-1) + <span class="keyword">...</span>
                1/Sigma(i-1,j) + 1/Sigma(i+1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n-L) = 1/Sigma(i-1,j);
            G(n,n+L) = 1/Sigma(i+1,j);
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

F=G\B';

Vmap = zeros(W,L);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(2)
hold <span class="string">on</span>
surf(Vmap);
hold <span class="string">off</span>
pause(0.001);

[Ex,Ey]=gradient(-Vmap);

figure(3)
hold <span class="string">on</span>
quiver(Ex,Ey);
axis([0 L 0 W])
hold <span class="string">off</span>
pause(0.001);

Jx=Sigma.*Ex;
Jy=Sigma.*Ey;

Cin = sqrt(Jx(1,L/2)^2+Jy(1,L/2)^2);
Cout = sqrt(Jx(W,L/2)^2+Jy(W,L/2)^2);
Curr = (Cin+Cout)*0.5;

figure(4)
hold <span class="string">on</span>
quiver(Jx,Jy);
axis([0 L 0 W])
<span class="comment">% axis([0 W 0 L])</span>
hold <span class="string">off</span>
pause(0.001);
</pre><img vspace="5" hspace="5" src="publishdoc_04.png" alt=""> <img vspace="5" hspace="5" src="publishdoc_05.png" alt=""> <img vspace="5" hspace="5" src="publishdoc_06.png" alt=""> <img vspace="5" hspace="5" src="publishdoc_07.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ELEC 4700 Assignment 2 - Finite Difference Method
%% 1a - 1D Electrostatic Potential
% Below is a solution to the 2D potential, but represented as a 3D
% surface with a constant potential in the y direction. One side of the
% rectangle is held at a potential of 1, the other side is held at 0, and
% dV/dy is set to 0 for the other two sides to allow for the flat 1D-like
% potential.
% 

clearvars
clearvars -GLOBAL
close all

L = 100;
W = 3/2*L;
Vo = 1;

G = sparse(L*W,L*W);
B = zeros(1,L*W);

for i=1:L
    for j=1:W
        n = j + (i-1)*W;
        
        if i==L 
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        elseif i==1 
            G(n,:) = 0;
            G(n,n) = 1;
        elseif j==1
            G(n,:) = 0;
            G(n,n) = -1;
            G(n,n+1) = 1;     % dV/dy = 0      
        elseif j==W
            G(n,:) = 0;
            G(n,n) = -1; 
            G(n,n-1) = 1;     % dV/dy = 0    
        else
            G(n,:) = 0;
            G(n,n) = -4;
            G(n,n-1) = 1;
            G(n,n+1) = 1;
            G(n,n-W) = 1;
            G(n,n+W) = 1;
        end
        
    end
end

spy(G);

F=G\B';

Vmap = zeros(L,W);

for i=1:L
    for j=1:W
        n = j + (i-1)*W;
        Vmap(i,j) = F(n);
    end
end


surf(Vmap);
pause(0.001);

%% 1b - 2D Electrostatic Potential (Finite Difference Method)
% Below is the solution to the potential system where instead of 
% having dV/dy = 0 for the last two sides, they are instead fixed at 0.

clearvars
clearvars -GLOBAL
close all

W = 100;
L = 3/2*W;
Vo = 1;

G = sparse(L*W,L*W);
B = zeros(1,L*W);

for i=1:L
    for j=1:W
        n = j + (i-1)*W;
        
        if i==1 || i==L
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        elseif j==1
            G(n,:) = 0;
            G(n,n) = 1;
        elseif j==W
            G(n,:) = 0;
            G(n,n) = 1;
        else
            G(n,:) = 0;
            G(n,n) = -4;
            G(n,n-1) = 1;
            G(n,n+1) = 1;
            G(n,n-W) = 1;
            G(n,n+W) = 1;
        end
        
    end
end

F=G\B';

Vmap = zeros(L,W);

for i=1:L
    for j=1:W
        n = j + (i-1)*W;
        Vmap(i,j) = F(n);
    end
end

surf(Vmap);
pause(0.001);

%% 1b - 2D Electrostatic Potential (Analytic Method)
% Below is the same potential system as before, but solved using the 
% analytic solution provided by the lab document. 

clearvars
clearvars -GLOBAL
close all

W = 100;
L = 3/2*W;
Vo = 1;
Terms = 60;

V = zeros(L+1,W);

for k=1:Terms
    for j=1:W
        for i=1:L+1
            V(i,j) = V(i,j) + 4*Vo/pi*1/(2*k-1)*cosh((2*k-1)*pi*(i-L/2-1)/W)/cosh((2*k-1)*pi*(L/2)/W)*sin((2*k-1)*pi*j/W);
        end
    end
    surf(V);
    pause(0.05);
end

%% 1b - Discussion
% 60 terms were used for the analytic series solution method, as it was
% determined that using larger values of the index n resulted in an
% inf/inf calculation, resulting in a NaN output from Matlab. Both the
% analytic and finite difference methods produced approximately the same
% potential distributions. One of the downsides of the finite difference
% method is the rough edges on the corners of the map, which the analytic
% method seemed not to have. However, the analytic method experiences the
% Gibbs phenomenon due to the termination of the series solution, resulting
% in overshoots of the solution at the map boundaries.
%
%



%% 2 - Non-Uniform Conductivity Map
%
%
%

clearvars
clearvars -GLOBAL
close all

L = 100;
W = 3/2*L;
Lb = round(L/3);
Wb = round(W/3);
Vo = 1;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

for i=1:Wb
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end
for i=round(W-Wb):W
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end

figure(1)
hold on
surf(Sigma);
axis([0 L 0 W])
hold off

G = sparse(L*W,L*W);
B = zeros(1,L*W);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        
        if i==1 && j==L/2
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        elseif i==W && j==L/2
            G(n,:) = 0;
            G(n,n) = 1;
        elseif j==1 && i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j); 
        elseif j==L && i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j-1));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+L) = 1/Sigma(i+1,j);
        elseif j==1 && i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i-1,j) + 1/Sigma(i,j+1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n-L) = 1/Sigma(i-1,j); 
        elseif j==L && i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i-1,j) + 1/Sigma(i,j-1));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n-L) = 1/Sigma(i-1,j);    
        elseif j==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1) + ...
                1/Sigma(i-1,j));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j); 
            G(n,n-L) = 1/Sigma(i-1,j);
        elseif j==L
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j-1) + ...
                1/Sigma(i-1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+L) = 1/Sigma(i+1,j); 
            G(n,n-L) = 1/Sigma(i-1,j);
        elseif i==1
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i+1,j) + 1/Sigma(i,j+1) + ...
                1/Sigma(i,j-1));
            G(n,n+1) = 1/Sigma(i,j+1);
            G(n,n+L) = 1/Sigma(i+1,j); 
            G(n,n-1) = 1/Sigma(i,j-1);
        elseif i==W
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i,j+1) + 1/Sigma(i,j-1) + ...
                1/Sigma(i-1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+1) = 1/Sigma(i,j+1); 
            G(n,n-L) = 1/Sigma(i-1,j);  
        else
            G(n,:) = 0;
            G(n,n) = -(1/Sigma(i,j+1) + 1/Sigma(i,j-1) + ...
                1/Sigma(i-1,j) + 1/Sigma(i+1,j));
            G(n,n-1) = 1/Sigma(i,j-1);
            G(n,n+1) = 1/Sigma(i,j+1); 
            G(n,n-L) = 1/Sigma(i-1,j); 
            G(n,n+L) = 1/Sigma(i+1,j); 
        end
        
    end
end

F=G\B';

Vmap = zeros(W,L);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    end
end

figure(2)
hold on
surf(Vmap);
hold off
pause(0.001);

[Ex,Ey]=gradient(-Vmap);

figure(3)
hold on
quiver(Ex,Ey);
axis([0 L 0 W])
hold off
pause(0.001);

Jx=Sigma.*Ex;
Jy=Sigma.*Ey;

Cin = sqrt(Jx(1,L/2)^2+Jy(1,L/2)^2);
Cout = sqrt(Jx(W,L/2)^2+Jy(W,L/2)^2);
Curr = (Cin+Cout)*0.5;

figure(4)
hold on
quiver(Jx,Jy);
axis([0 L 0 W])
% axis([0 W 0 L])
hold off
pause(0.001);





##### SOURCE END #####
--></body></html>