
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ELEC 4700 Assignment 1 - Monte-Carlo Modeling of Electron Transport</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-02-04"><meta name="DC.source" content="assignment1.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ELEC 4700 Assignment 1 - Monte-Carlo Modeling of Electron Transport</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">1 - Electron Modelling</a></li><li><a href="#2">Part 1 Discussion</a></li><li><a href="#3">2 - Collisions with MFP</a></li><li><a href="#4">Part 2 Discussion</a></li><li><a href="#5">3 - Enhancements</a></li><li><a href="#6">Part 3 Discussion</a></li></ul></div><h2>1 - Electron Modelling<a name="1"></a></h2><p>a) Since we are doing a 2D simulation of the electrons, there are 2 degrees of freedom. Since <img src="assignment1_eq13388646663717879984.png" alt="$1/2mv^2$"> of energy is attibuted to each degree of freedom, and since 1/2kT is associated with each degree of freedom, then for our 2D system:</p><p><img src="assignment1_eq18103751498524358314.png" alt="$$ \frac{1}{2}mv_{th}^2 =k_BT $$"></p><p>Solving for <img src="assignment1_eq03266579450162345072.png" alt="$v_{th}$">, using the fact that the effective mass of an electron <img src="assignment1_eq03906289204929598933.png" alt="$m_n$"> is <img src="assignment1_eq02509289632475712443.png" alt="$0.26$"> the rest mass <img src="assignment1_eq01724085064419042116.png" alt="$m_o$">:</p><p><img src="assignment1_eq15177317359856562791.png" alt="$$ v_{th} = 1.870 \times 10^5 m/s $$"></p><p>b) <img src="assignment1_eq10059201645459450990.png" alt="$MFP = (v_{th})(\tau _{mn}) = (1.870 \times 10^5 m/s)(0.2ps) = 37.4nm$"></p><p>Following is the code for part 1:</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

C.m_0 = 9.10938215e-31;             <span class="comment">% electron mass</span>
C.kb = 1.3806504e-23;               <span class="comment">% Boltzmann constant</span>

nElectrons = 10000;
nPlot=20; <span class="comment">% number of electrons to actually plot</span>
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; <span class="comment">% since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s</span>
TStop = 1e-12; <span class="comment">% 1000 timesteps</span>
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); <span class="comment">% using 2 degrees of freedom</span>
time = 0;
Temp = T; <span class="comment">% temperature variable that updates in TempCalc</span>
taumn = 0.2e-12; <span class="comment">% average time between collisions</span>
cc = jet(nPlot); <span class="comment">% colorscale used to plot different electron colors</span>

x = rand(1, nElectrons)*L; <span class="comment">% assigning random initial particle positions</span>
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; <span class="comment">% random velocity direction</span>
Vx = cos(Theta)*Vth;
Vy = sin(Theta)*Vth;

figure(1)
hFig1 = figure(1);
set(hFig1, <span class="string">'Position'</span>, [500 0 600 1000])

<span class="keyword">for</span> i=0:dt:TStop
    time = i;

    subplot(2,1,1); <span class="comment">% plotting electron positions</span>
    hold <span class="string">on</span>
    <span class="keyword">for</span> j=1:nPlot
        plot(x(j), y(j), <span class="string">'o'</span>,<span class="string">'markers'</span>, 1, <span class="string">'Color'</span>, cc(j,:));
    <span class="keyword">end</span>
    axis([0 L 0 W]);

    V2tot=Vx.*Vx+Vy.*Vy; <span class="comment">% calculated temp based on total velocities</span>
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;

    subplot(2,1,2); <span class="comment">% plotting temp vs. time</span>
    plot(time,Temp, <span class="string">'ro'</span>, <span class="string">'markers'</span>,1,<span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
    hold <span class="string">on</span>
    axis([0 TStop 250 350]);
    xlabel(<span class="string">'Time(s)'</span>);
    ylabel(<span class="string">'Temp (K)'</span>);
    grid <span class="string">on</span>
    title(<span class="string">'Temperature vs. Time'</span>);

    x = x - dt * Vx; <span class="comment">% moving the particles in one time step</span>
    y = y - dt * Vy;

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% specular and periodic boundaries</span>
        <span class="keyword">if</span> x(j) &gt; L
            x(j) = x(j) - L;
        <span class="keyword">elseif</span> x(j) &lt; 0
            x(j) = x(j) + L;
        <span class="keyword">end</span>

         <span class="keyword">if</span> y(j) &gt; W
             Vy(j) = -Vy(j);
         <span class="keyword">elseif</span> y(j) &lt; 0
             Vy(j) = -Vy(j);
         <span class="keyword">end</span>
    <span class="keyword">end</span>

    pause(0.001)

<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="assignment1_01.png" alt=""> <h2>Part 1 Discussion<a name="2"></a></h2><p>As shown in the temperature vs. time plot, the temperature does indeed remain at 300K, since the velocities of the electrons remains constant the entire time. As will be seen in the next sections, rethermalization of the electrons alters the velocities, and thus the temperature will fluctuate accordingly.</p><h2>2 - Collisions with MFP<a name="3"></a></h2><p>As mentioned in slideshow "3-MonteCarlo" on slide 16, the velocity for each direction (x, y) can be given by a gaussian distribution centered around the thermal velocity <img src="assignment1_eq03266579450162345072.png" alt="$v_{th}$">, with a standard deviation of <img src="assignment1_eq03791181932313570128.png" alt="$(\frac{k_bT}{m})^{0.5}$">. This method was used to determine the velocity components for the simulation, but clearly this resulted in an issue as the average temperature for the system becomes ~450K even with the initial thermal velocity being calculated with 300K. The Maxwell-Boltzman distribution would have been used to find the individual velocity components, but it was unclear how to do so in Matlab. Due to this issue, calculated values of average thermal velocity, mean free path, and average time between collisions are all incorrect. However, the methods used to calculate these parameters still appear valid.</p><p>Following is the code for part 2:</p><pre class="codeinput">C.m_0 = 9.10938215e-31;             <span class="comment">% electron mass</span>
C.kb = 1.3806504e-23;               <span class="comment">% Boltzmann constant</span>

nElectrons = 10000;
nPlot=20; <span class="comment">% number of electrons to actually plot</span>
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; <span class="comment">% since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s</span>
TStop = 1e-12; <span class="comment">% 1000 timesteps</span>
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); <span class="comment">% using 2 degrees of freedom</span>
time = 0;
Temp = T; <span class="comment">% temperature variable that updates in TempCalc</span>
taumn = 0.2e-12; <span class="comment">% average time between collisions</span>
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); <span class="comment">% standard deviation on vth</span>
cc = jet(nPlot); <span class="comment">% colorscale used to plot different electron colors</span>

collisionT = zeros(200,nElectrons); <span class="comment">% matrices for tracking collision time and velocities</span>
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; <span class="comment">% assigning random initial particle positions</span>
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; <span class="comment">% selecting Vx and Vy from Gaussian centered at vth</span>
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons <span class="comment">% calculation of initial average velocity</span>

figure(2)
hFig2 = figure(2);
set(hFig2, <span class="string">'Position'</span>, [500 0 600 1000])

<span class="keyword">for</span> i=0:dt:TStop
    time = i;

    subplot(2,1,1); <span class="comment">% plotting electron positions</span>
    hold <span class="string">on</span>
    <span class="keyword">for</span> j=1:nPlot
        plot(x(j), y(j), <span class="string">'o'</span>,<span class="string">'markers'</span>, 1, <span class="string">'Color'</span>, cc(j,:));
    <span class="keyword">end</span>
    axis([0 L 0 W]);

    V2tot=Vx.*Vx+Vy.*Vy; <span class="comment">% calculated temp based on total velocities</span>
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;

    subplot(2,1,2); <span class="comment">% plotting temp vs. time</span>
    plot(time,Temp, <span class="string">'ro'</span>, <span class="string">'markers'</span>,1,<span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
    hold <span class="string">on</span>
    axis([0 TStop 350 550]);
    xlabel(<span class="string">'Time(s)'</span>);
    ylabel(<span class="string">'Temp (K)'</span>);
    grid <span class="string">on</span>
    title(<span class="string">'Temperature vs. Time'</span>);

    x = x - dt * Vx; <span class="comment">% moving the particles in one time step</span>
    y = y - dt * Vy;

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% specular and periodic boundaries</span>
        <span class="keyword">if</span> x(j) &gt; L
            x(j) = x(j) - L;
        <span class="keyword">elseif</span> x(j) &lt; 0
            x(j) = x(j) + L;
        <span class="keyword">end</span>

         <span class="keyword">if</span> y(j) &gt; W
             Vy(j) = -Vy(j);
         <span class="keyword">elseif</span> y(j) &lt; 0
             Vy(j) = -Vy(j);
         <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% collision, mfp, and mean time between collisions tracking</span>
        <span class="keyword">if</span> (1-exp(-dt/taumn)) &gt; rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;

            Theta = rand(1, 1)*2*pi; <span class="comment">% rethermalizing after collision</span>
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    pause(0.000001)

<span class="keyword">end</span>

figure(3) <span class="comment">% histogram of final velocity distribution</span>
histogram(sqrt(Vx.^2+Vy.^2), 20);
hold <span class="string">on</span>
xlabel(<span class="string">'Binned velocities (m/s)'</span>);
ylabel(<span class="string">'Frequency'</span>);
grid <span class="string">on</span>
title(<span class="string">'Histogram of velocities of 10000 electrons'</span>);
hold <span class="string">off</span>

MFP=0;
TBC=0;

<span class="keyword">for</span> i=1:nElectrons <span class="comment">% calculation of time between collisions (TBC) and mean free path (MFP)</span>
    <span class="keyword">for</span> j=1:collisionIndex(i)
        <span class="keyword">if</span> j ~= 1
            TBC = TBC + collisionT(j,i)-collisionT(j-1,i);
            MFP = MFP + (collisionT(j,i)-collisionT(j-1,i))*(collisionV(j,i)-collisionV(j-1,i));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

TBC = TBC/collisions
MFP = MFP/collisions
</pre><pre class="codeoutput">
avgV =

   2.0423e+05


TBC =

   1.6015e-13


MFP =

   7.8686e-09

</pre><img vspace="5" hspace="5" src="assignment1_02.png" alt=""> <img vspace="5" hspace="5" src="assignment1_03.png" alt=""> <h2>Part 2 Discussion<a name="4"></a></h2><p>As shown in the histogram of velocities, even though the individual components were selected from Gaussian distributions, it appears that the overal velocity distribution is similar to the Maxwell-Boltzman distribution. As seen from the particle trajectories they are clearly exhibiting scattering in random directions at random intervals. The temperature vs. time plot shows that although the temperature exhibits minor fluctuations over time, it remains centered around ~450K. If the correct distributions were used, it would be assumed that this central temperature would be 300K instead. Comparing the TBC and MPF found in part 1 and the ones calculated in this code, there is clearly a discrepancy. As mentioned before, this is likely due to the average thermal velocity being larger than it should be, due the way velocities were selected from Gaussian distributions.</p><h2>3 - Enhancements<a name="5"></a></h2><p>Following is the code for part 3:</p><pre class="codeinput">C.m_0 = 9.10938215e-31;             <span class="comment">% electron mass</span>
C.kb = 1.3806504e-23;               <span class="comment">% Boltzmann constant</span>

nElectrons = 10000;
nPlot=20; <span class="comment">% number of electrons to actually plot</span>
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; <span class="comment">% since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s</span>
TStop = 1e-12; <span class="comment">% 1000 timesteps</span>
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); <span class="comment">% using 2 degrees of freedom</span>
time = 0;
Temp = T; <span class="comment">% temperature variable that updates in TempCalc</span>
taumn = 0.2e-12; <span class="comment">% average time between collisions</span>
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); <span class="comment">% standard deviation on vth</span>
cc = jet(nPlot); <span class="comment">% colorscale used to plot different electron colors</span>

collisionT = zeros(200,nElectrons); <span class="comment">% matrices for tracking collision time and velocities</span>
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; <span class="comment">% assigning random initial particle positions</span>
y = rand(1, nElectrons)*W;

<span class="keyword">for</span> i=1:nElectrons <span class="comment">% ensuring particles do not start in boxed boundaries</span>
   <span class="keyword">while</span>(1)
      <span class="keyword">if</span> ( x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7))
          x(i) = rand*L;
          y(i) = rand*W;
      <span class="keyword">else</span>
        <span class="keyword">break</span>
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

Theta = rand(1, nElectrons)*2*pi; <span class="comment">% selecting Vx and Vy from Gaussian centered at vth</span>
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons

figure(4)
hFig4 = figure(4);
set(hFig4, <span class="string">'Position'</span>, [500 0 600 1000])

subplot(2,1,1); <span class="comment">% plotting lines of box boundaries</span>
hold <span class="string">on</span>
plot([0.8,0.8]*1e-7,[0,0.4]*1e-7, <span class="string">'r-'</span>)
plot([0.8,0.8]*1e-7,[0.6,1]*1e-7, <span class="string">'r-'</span>)
plot([1.2,1.2]*1e-7,[0,0.4]*1e-7, <span class="string">'r-'</span>)
plot([1.2,1.2]*1e-7,[0.6,1]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0,0]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0.4,0.4]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0.6,0.6]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[1,1]*1e-7, <span class="string">'r-'</span>)

<span class="keyword">for</span> i=0:dt:TStop
    time = i;

    subplot(2,1,1); <span class="comment">% plotting electron positions</span>
    hold <span class="string">on</span>
    <span class="keyword">for</span> j=1:nPlot
        plot(x(j), y(j), <span class="string">'o'</span>,<span class="string">'markers'</span>, 1, <span class="string">'Color'</span>, cc(j,:));
    <span class="keyword">end</span>
    axis([0 L 0 W]);

    V2tot=Vx.*Vx+Vy.*Vy; <span class="comment">% calculated temp based on total velocities</span>
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;

    subplot(2,1,2); <span class="comment">% plotting temp vs. time</span>
    plot(time,Temp, <span class="string">'ro'</span>, <span class="string">'markers'</span>,1,<span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
    hold <span class="string">on</span>
    axis([0 TStop 350 550]);
    xlabel(<span class="string">'Time(s)'</span>);
    ylabel(<span class="string">'Temp (K)'</span>);
    grid <span class="string">on</span>
    title(<span class="string">'Temperature vs. Time'</span>);

    x = x - dt * Vx; <span class="comment">% moving the particles in one time step</span>
    y = y - dt * Vy;

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% specular and periodic boundaries</span>
        <span class="keyword">if</span> x(j) &gt; L
            x(j) = x(j) - L;
        <span class="keyword">elseif</span> x(j) &lt; 0
            x(j) = x(j) + L;
        <span class="keyword">end</span>

         <span class="keyword">if</span> y(j) &gt; W
             Vy(j) = -Vy(j);
         <span class="keyword">elseif</span> y(j) &lt; 0
             Vy(j) = -Vy(j);
         <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% collision, mfp, and mean time between collisions tracking</span>
        <span class="keyword">if</span> (1-exp(-dt/taumn)) &gt; rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;

            Theta = rand(1, 1)*2*pi; <span class="comment">% rethermalizing after collision</span>
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% the following code is uncommented if diffusive boundaries are desired</span>
    <span class="comment">%%%%%%%%% BlockBordersDiffusive Begin %%%%%%%%%%%</span>

<span class="comment">%     for i=1:nElectrons % rethermalized when hit boundary, theta defines scattering angle so it reflects away from boundary</span>
<span class="comment">%         if Vy(i)&lt;0 &amp;&amp; y(i)&gt;0.6e-7 &amp;&amp; y(i)&lt;0.61e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7</span>
<span class="comment">%             Theta = rand*pi;</span>
<span class="comment">%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%         elseif Vy(i)&gt;0 &amp;&amp; y(i)&lt;0.4e-7 &amp;&amp; y(i)&gt;0.39e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7</span>
<span class="comment">%             Theta = rand*pi+pi;</span>
<span class="comment">%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%         elseif Vx(i)&lt;0 &amp;&amp; x(i)&gt;0.8e-7 &amp;&amp; x(i)&lt;0.81e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)</span>
<span class="comment">%             Theta = rand*pi-pi/2;</span>
<span class="comment">%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%         elseif Vx(i)&gt;0 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;1.19e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)</span>
<span class="comment">%             Theta = rand*pi+pi/2;</span>
<span class="comment">%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));</span>
<span class="comment">%         end</span>
<span class="comment">%     end</span>

    <span class="comment">%%%%%%%%% BlockBordersDiffusive End %%%%%%%%%%%</span>


    <span class="comment">% the following code is uncommented if specular boundaries are desired</span>
    <span class="comment">%%%%%%%%% BlockBorders Begin %%%%%%%%%%%</span>

    <span class="keyword">for</span> i=1:nElectrons <span class="comment">% conditions for meeting a boundary, specular reflection by inverting x or y velocity</span>
        <span class="keyword">if</span> Vy(i)&lt;0 &amp;&amp; y(i)&gt;0.6e-7 &amp;&amp; y(i)&lt;0.61e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7
            Vy(i)=-Vy(i);
        <span class="keyword">elseif</span> Vy(i)&gt;0 &amp;&amp; y(i)&lt;0.4e-7 &amp;&amp; y(i)&gt;0.39e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7
            Vy(i)=-Vy(i);
        <span class="keyword">elseif</span> Vx(i)&lt;0 &amp;&amp; x(i)&gt;0.8e-7 &amp;&amp; x(i)&lt;0.81e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)
            Vx(i)=-Vx(i);
        <span class="keyword">elseif</span> Vx(i)&gt;0 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;1.19e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)
            Vx(i)=-Vx(i);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%%%%%%%%% BlockBorders End %%%%%%%%%%%</span>

    pause(0.001)

<span class="keyword">end</span>

MFP=0;
TBC=0;

<span class="keyword">for</span> i=1:nElectrons <span class="comment">% calculation of time between collisions (TBC) and mean free path (MFP)</span>
    <span class="keyword">for</span> j=1:collisionIndex(i)
        <span class="keyword">if</span> j ~= 1
            TBC = TBC + collisionT(j,i)-collisionT(j-1,i);
            MFP = MFP + (collisionT(j,i)-collisionT(j-1,i))*(collisionV(j,i)-collisionV(j-1,i));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

TBC = TBC/collisions
MFP = MFP/collisions

figure(5) <span class="comment">% plotting electron density map in a 50x50 grid</span>
hold <span class="string">on</span>
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title(<span class="string">'Electron Density Map'</span>);
hold <span class="string">off</span>

V5050 = zeros(50);

<span class="keyword">for</span> h=1:nElectrons <span class="comment">% calculating velocities for temperature calculation</span>
    <span class="keyword">for</span> i=1:50
        <span class="keyword">for</span> j=1:50
            <span class="keyword">if</span> x(h)&gt;((i-1)/50*L) &amp;&amp; x(h)&lt;(i/50*L) &amp;&amp; y(h)&gt;((j-1)/50*W) &amp;&amp; y(h)&lt;(j/50*W)
                V5050(i,j)=Vx(h)^2+Vy(h)^2;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">for</span> i=1:50 <span class="comment">% taking average velocity per cell</span>
    <span class="keyword">for</span> j=1:50
       <span class="keyword">if</span> n(i,j)~=0
          V5050(i,j) = V5050(i,j)/n(i,j);
       <span class="keyword">else</span>
          V5050(i,j) = 0;
       <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(6) <span class="comment">% plotting temperature density</span>
hold <span class="string">on</span>
m=V5050.*0.5*0.26*C.m_0/C.kb;
pcolor(m');
colorbar;
title(<span class="string">'Temperature Map'</span>);
hold <span class="string">off</span>
</pre><pre class="codeoutput">
avgV =

   2.0582e+05


TBC =

   1.6062e-13


MFP =

   8.0319e-09

</pre><img vspace="5" hspace="5" src="assignment1_04.png" alt=""> <img vspace="5" hspace="5" src="assignment1_05.png" alt=""> <img vspace="5" hspace="5" src="assignment1_06.png" alt=""> <h2>Part 3 Discussion<a name="6"></a></h2><p>As shown in the trajectories plot, all of the electrons begin outside of the boundaries and also scatter off of the boundaries when encountered. The specular scattering is observed in this plot, but to enable diffuse scattering the labelled code in the section above would need to be uncommented, and the specular code would need to be commented. The maps of electron density and temperature appear to show some electrons in the boundaries, but that is only due to the histogram having bins that include the borders of the boundaries.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ELEC 4700 Assignment 1 - Monte-Carlo Modeling of Electron Transport
%% 1 - Electron Modelling
% a) Since we are doing a 2D simulation of the electrons, there are 2 
% degrees of freedom. Since $1/2mv^2$ of energy is attibuted to each degree
% of freedom, and since 1/2kT is associated with each degree of freedom, 
% then for our 2D system:
%
% $$ \frac{1}{2}mv_{th}^2 =k_BT $$
%
% Solving for $v_{th}$, using the fact that the effective mass of an
% electron $m_n$ is $0.26$ the rest mass $m_o$:
%
% $$ v_{th} = 1.870 \times 10^5 m/s $$
%
% b) 
% $MFP = (v_{th})(\tau _{mn}) = (1.870 \times 10^5 m/s)(0.2ps) = 37.4nm$
%
% Following is the code for part 1:

clearvars
clearvars -GLOBAL
close all

C.m_0 = 9.10938215e-31;             % electron mass
C.kb = 1.3806504e-23;               % Boltzmann constant

nElectrons = 10000;
nPlot=20; % number of electrons to actually plot
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; % since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s
TStop = 1e-12; % 1000 timesteps
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); % using 2 degrees of freedom
time = 0;
Temp = T; % temperature variable that updates in TempCalc
taumn = 0.2e-12; % average time between collisions
cc = jet(nPlot); % colorscale used to plot different electron colors

x = rand(1, nElectrons)*L; % assigning random initial particle positions
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; % random velocity direction
Vx = cos(Theta)*Vth;
Vy = sin(Theta)*Vth;

figure(1)
hFig1 = figure(1);
set(hFig1, 'Position', [500 0 600 1000])

for i=0:dt:TStop
    time = i; 
    
    subplot(2,1,1); % plotting electron positions
    hold on
    for j=1:nPlot
        plot(x(j), y(j), 'o','markers', 1, 'Color', cc(j,:));
    end
    axis([0 L 0 W]);
    
    V2tot=Vx.*Vx+Vy.*Vy; % calculated temp based on total velocities
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;
    
    subplot(2,1,2); % plotting temp vs. time
    plot(time,Temp, 'ro', 'markers',1,'MarkerFaceColor', 'b');
    hold on
    axis([0 TStop 250 350]);
    xlabel('Time(s)');
    ylabel('Temp (K)');
    grid on
    title('Temperature vs. Time');
    
    x = x - dt * Vx; % moving the particles in one time step
    y = y - dt * Vy;
    
    for j=1:nElectrons % specular and periodic boundaries
        if x(j) > L
            x(j) = x(j) - L;
        elseif x(j) < 0
            x(j) = x(j) + L;
        end
        
         if y(j) > W
             Vy(j) = -Vy(j);
         elseif y(j) < 0
             Vy(j) = -Vy(j);
         end
    end

    pause(0.001)
    
end
%% Part 1 Discussion
% As shown in the temperature vs. time plot, the temperature does indeed
% remain at 300K, since the velocities of the electrons remains constant
% the entire time. As will be seen in the next sections, rethermalization
% of the electrons alters the velocities, and thus the temperature will
% fluctuate accordingly.

%% 2 - Collisions with MFP
% As mentioned in slideshow "3-MonteCarlo" on slide 16, the velocity for
% each direction (x, y) can be given by a gaussian distribution centered
% around the thermal velocity $v_{th}$, with a standard deviation of
% $(\frac{k_bT}{m})^{0.5}$. This method was used to determine the velocity
% components for the simulation, but clearly this resulted in an issue as
% the average temperature for the system becomes ~450K even with the
% initial thermal velocity being calculated with 300K. The Maxwell-Boltzman
% distribution would have been used to find the individual velocity
% components, but it was unclear how to do so in Matlab. Due to this issue,
% calculated values of average thermal velocity, mean free path, and
% average time between collisions are all incorrect. However, the methods
% used to calculate these parameters still appear valid. 
%
% Following is the code for part 2:

C.m_0 = 9.10938215e-31;             % electron mass
C.kb = 1.3806504e-23;               % Boltzmann constant

nElectrons = 10000;
nPlot=20; % number of electrons to actually plot
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; % since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s
TStop = 1e-12; % 1000 timesteps
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); % using 2 degrees of freedom
time = 0;
Temp = T; % temperature variable that updates in TempCalc
taumn = 0.2e-12; % average time between collisions
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); % standard deviation on vth
cc = jet(nPlot); % colorscale used to plot different electron colors

collisionT = zeros(200,nElectrons); % matrices for tracking collision time and velocities
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; % assigning random initial particle positions
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; % selecting Vx and Vy from Gaussian centered at vth
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons % calculation of initial average velocity

figure(2)
hFig2 = figure(2);
set(hFig2, 'Position', [500 0 600 1000])

for i=0:dt:TStop
    time = i;

    subplot(2,1,1); % plotting electron positions
    hold on
    for j=1:nPlot
        plot(x(j), y(j), 'o','markers', 1, 'Color', cc(j,:));
    end
    axis([0 L 0 W]);
    
    V2tot=Vx.*Vx+Vy.*Vy; % calculated temp based on total velocities
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;
    
    subplot(2,1,2); % plotting temp vs. time
    plot(time,Temp, 'ro', 'markers',1,'MarkerFaceColor', 'b');
    hold on
    axis([0 TStop 350 550]);
    xlabel('Time(s)');
    ylabel('Temp (K)');
    grid on
    title('Temperature vs. Time');
    
    x = x - dt * Vx; % moving the particles in one time step
    y = y - dt * Vy;
    
    for j=1:nElectrons % specular and periodic boundaries
        if x(j) > L
            x(j) = x(j) - L;
        elseif x(j) < 0
            x(j) = x(j) + L;
        end
        
         if y(j) > W
             Vy(j) = -Vy(j);
         elseif y(j) < 0
             Vy(j) = -Vy(j);
         end
    end
    
    for j=1:nElectrons % collision, mfp, and mean time between collisions tracking
        if (1-exp(-dt/taumn)) > rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;
            
            Theta = rand(1, 1)*2*pi; % rethermalizing after collision
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        end
    end
    
    pause(0.000001)
    
end

figure(3) % histogram of final velocity distribution
histogram(sqrt(Vx.^2+Vy.^2), 20);
hold on
xlabel('Binned velocities (m/s)');
ylabel('Frequency');
grid on
title('Histogram of velocities of 10000 electrons');
hold off

MFP=0;
TBC=0;

for i=1:nElectrons % calculation of time between collisions (TBC) and mean free path (MFP)
    for j=1:collisionIndex(i)
        if j ~= 1
            TBC = TBC + collisionT(j,i)-collisionT(j-1,i);
            MFP = MFP + (collisionT(j,i)-collisionT(j-1,i))*(collisionV(j,i)-collisionV(j-1,i));
        end
    end
end

TBC = TBC/collisions
MFP = MFP/collisions

%% Part 2 Discussion
% As shown in the histogram of velocities, even though the individual
% components were selected from Gaussian distributions, it appears that
% the overal velocity distribution is similar to the Maxwell-Boltzman
% distribution. As seen from the particle trajectories they are clearly
% exhibiting scattering in random directions at random intervals. The
% temperature vs. time plot shows that although the temperature exhibits
% minor fluctuations over time, it remains centered around ~450K. If the
% correct distributions were used, it would be assumed that this central
% temperature would be 300K instead. Comparing the TBC and MPF found in
% part 1 and the ones calculated in this code, there is clearly a
% discrepancy. As mentioned before, this is likely due to the average thermal velocity
% being larger than it should be, due the way velocities were selected from
% Gaussian distributions.

%% 3 - Enhancements
%
% Following is the code for part 3:

C.m_0 = 9.10938215e-31;             % electron mass
C.kb = 1.3806504e-23;               % Boltzmann constant

nElectrons = 10000;
nPlot=20; % number of electrons to actually plot
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; % since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s
TStop = 1e-12; % 1000 timesteps
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); % using 2 degrees of freedom
time = 0;
Temp = T; % temperature variable that updates in TempCalc
taumn = 0.2e-12; % average time between collisions
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); % standard deviation on vth
cc = jet(nPlot); % colorscale used to plot different electron colors

collisionT = zeros(200,nElectrons); % matrices for tracking collision time and velocities
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; % assigning random initial particle positions
y = rand(1, nElectrons)*W;

for i=1:nElectrons % ensuring particles do not start in boxed boundaries
   while(1) 
      if ( x(i)<1.2e-7 && x(i)>0.8e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)) 
          x(i) = rand*L;
          y(i) = rand*W;
      else
        break
      end
   end
end

Theta = rand(1, nElectrons)*2*pi; % selecting Vx and Vy from Gaussian centered at vth
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons

figure(4)
hFig4 = figure(4);
set(hFig4, 'Position', [500 0 600 1000])

subplot(2,1,1); % plotting lines of box boundaries
hold on
plot([0.8,0.8]*1e-7,[0,0.4]*1e-7, 'r-')
plot([0.8,0.8]*1e-7,[0.6,1]*1e-7, 'r-')
plot([1.2,1.2]*1e-7,[0,0.4]*1e-7, 'r-')
plot([1.2,1.2]*1e-7,[0.6,1]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0,0]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0.4,0.4]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0.6,0.6]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[1,1]*1e-7, 'r-')

for i=0:dt:TStop
    time = i;
    
    subplot(2,1,1); % plotting electron positions
    hold on
    for j=1:nPlot
        plot(x(j), y(j), 'o','markers', 1, 'Color', cc(j,:));
    end
    axis([0 L 0 W]);
    
    V2tot=Vx.*Vx+Vy.*Vy; % calculated temp based on total velocities
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;
    
    subplot(2,1,2); % plotting temp vs. time
    plot(time,Temp, 'ro', 'markers',1,'MarkerFaceColor', 'b');
    hold on
    axis([0 TStop 350 550]);
    xlabel('Time(s)');
    ylabel('Temp (K)');
    grid on
    title('Temperature vs. Time');
    
    x = x - dt * Vx; % moving the particles in one time step
    y = y - dt * Vy;
    
    for j=1:nElectrons % specular and periodic boundaries
        if x(j) > L
            x(j) = x(j) - L;
        elseif x(j) < 0
            x(j) = x(j) + L;
        end
        
         if y(j) > W
             Vy(j) = -Vy(j);
         elseif y(j) < 0
             Vy(j) = -Vy(j);
         end
    end
    
    for j=1:nElectrons % collision, mfp, and mean time between collisions tracking
        if (1-exp(-dt/taumn)) > rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;
            
            Theta = rand(1, 1)*2*pi; % rethermalizing after collision
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        end
    end
    
    % the following code is uncommented if diffusive boundaries are desired
    %%%%%%%%% BlockBordersDiffusive Begin %%%%%%%%%%%
    
%     for i=1:nElectrons % rethermalized when hit boundary, theta defines scattering angle so it reflects away from boundary
%         if Vy(i)<0 && y(i)>0.6e-7 && y(i)<0.61e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
%             Theta = rand*pi;
%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
%         elseif Vy(i)>0 && y(i)<0.4e-7 && y(i)>0.39e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
%             Theta = rand*pi+pi;
%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
%         elseif Vx(i)<0 && x(i)>0.8e-7 && x(i)<0.81e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
%             Theta = rand*pi-pi/2;
%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
%         elseif Vx(i)>0 && x(i)<1.2e-7 && x(i)>1.19e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
%             Theta = rand*pi+pi/2;
%             Vx(i) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
%             Vy(i) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
%         end
%     end
    
    %%%%%%%%% BlockBordersDiffusive End %%%%%%%%%%%
    

    % the following code is uncommented if specular boundaries are desired
    %%%%%%%%% BlockBorders Begin %%%%%%%%%%%
    
    for i=1:nElectrons % conditions for meeting a boundary, specular reflection by inverting x or y velocity
        if Vy(i)<0 && y(i)>0.6e-7 && y(i)<0.61e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
            Vy(i)=-Vy(i);
        elseif Vy(i)>0 && y(i)<0.4e-7 && y(i)>0.39e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
            Vy(i)=-Vy(i);
        elseif Vx(i)<0 && x(i)>0.8e-7 && x(i)<0.81e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
            Vx(i)=-Vx(i);
        elseif Vx(i)>0 && x(i)<1.2e-7 && x(i)>1.19e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
            Vx(i)=-Vx(i);
        end
    end
    
    %%%%%%%%% BlockBorders End %%%%%%%%%%%
    
    pause(0.001)
    
end

MFP=0;
TBC=0;

for i=1:nElectrons % calculation of time between collisions (TBC) and mean free path (MFP)
    for j=1:collisionIndex(i)
        if j ~= 1
            TBC = TBC + collisionT(j,i)-collisionT(j-1,i);
            MFP = MFP + (collisionT(j,i)-collisionT(j-1,i))*(collisionV(j,i)-collisionV(j-1,i));
        end
    end
end

TBC = TBC/collisions
MFP = MFP/collisions

figure(5) % plotting electron density map in a 50x50 grid
hold on
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title('Electron Density Map');
hold off

V5050 = zeros(50);

for h=1:nElectrons % calculating velocities for temperature calculation
    for i=1:50
        for j=1:50
            if x(h)>((i-1)/50*L) && x(h)<(i/50*L) && y(h)>((j-1)/50*W) && y(h)<(j/50*W)
                V5050(i,j)=Vx(h)^2+Vy(h)^2;
            end
        end
    end
end

for i=1:50 % taking average velocity per cell
    for j=1:50
       if n(i,j)~=0
          V5050(i,j) = V5050(i,j)/n(i,j);  
       else
          V5050(i,j) = 0; 
       end
    end
end

figure(6) % plotting temperature density
hold on
m=V5050.*0.5*0.26*C.m_0/C.kb;
pcolor(m');
colorbar;
title('Temperature Map');
hold off

%% Part 3 Discussion
% As shown in the trajectories plot, all of the electrons begin outside of
% the boundaries and also scatter off of the boundaries when encountered.
% The specular scattering is observed in this plot, but to enable diffuse
% scattering the labelled code in the section above would need to be
% uncommented, and the specular code would need to be commented.
% The maps of electron density and temperature appear to show some
% electrons in the boundaries, but that is only due to the histogram
% having bins that include the borders of the boundaries. 
##### SOURCE END #####
--></body></html>