
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ELEC 4700 Assignment 3 - Monte-Carlo/Finite Difference Method</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-03-18"><meta name="DC.source" content="A3publish.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ELEC 4700 Assignment 3 - Monte-Carlo/Finite Difference Method</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">1 - Monte-Carlo Simluation</a></li><li><a href="#2">1 - Monte-Carlo Simluation Discussion</a></li><li><a href="#3">2 - Finite Difference Method</a></li><li><a href="#4">3 - Combination</a></li><li><a href="#5">3 - Combination Discussion</a></li></ul></div><h2>1 - Monte-Carlo Simluation<a name="1"></a></h2><p>Below is the code to simulate electron motion under the influence of an external electric field.</p><pre class="codeinput">C.m_0 = 9.10938215e-31;             <span class="comment">% electron mass</span>
C.kb = 1.3806504e-23;               <span class="comment">% Boltzmann constant</span>
C.q_0 = 1.60217653e-19;             <span class="comment">% electron charge</span>

nElectrons = 10000;
nPlot=20; <span class="comment">% number of electrons to actually plot</span>
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; <span class="comment">% since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s</span>
TStop = 1e-12; <span class="comment">% 1000 timesteps</span>
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); <span class="comment">% using 2 degrees of freedom</span>
time = 0;
Temp = T; <span class="comment">% temperature variable that updates in TempCalc</span>
taumn = 0.2e-12; <span class="comment">% average time between collisions</span>
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); <span class="comment">% standard deviation on vth</span>
cc = jet(nPlot); <span class="comment">% colorscale used to plot different electron colors</span>

delVx = 0.8; <span class="comment">% voltage difference in x direction</span>
delVy = 0;

Ex = delVx/L;
Ey = delVy/W;

collisionT = zeros(200,nElectrons); <span class="comment">% matrices for tracking collision time and velocities</span>
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; <span class="comment">% assigning random initial particle positions</span>
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; <span class="comment">% selecting Vx and Vy from Gaussian centered at vth</span>
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons <span class="comment">% calculation of initial average velocity</span>

currentD = zeros(1,1000);
currentDTime = linspace(1,1000,1000);

figure(2)
hFig2 = figure(2);
set(hFig2, <span class="string">'Position'</span>, [0 0 1200 1000])

q=0;

<span class="keyword">for</span> i=0:dt:TStop
    time = i;
    q=q+1;

    hold <span class="string">on</span>

    plot(x(1:30), y(1:30), <span class="string">'bo'</span>,<span class="string">'markers'</span>, 1);
    axis([0 L 0 W]);

    V2tot=Vx.*Vx+Vy.*Vy; <span class="comment">% calculated temp based on total velocities</span>
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;

    x = x - dt * Vx; <span class="comment">% moving the particles in one time step</span>
    y = y - dt * Vy;

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% specular and periodic boundaries</span>
        <span class="keyword">if</span> x(j) &gt; L
            x(j) = x(j) - L;
        <span class="keyword">elseif</span> x(j) &lt; 0
            x(j) = x(j) + L;
        <span class="keyword">end</span>

         <span class="keyword">if</span> y(j) &gt; W
             Vy(j) = -Vy(j);
         <span class="keyword">elseif</span> y(j) &lt; 0
             Vy(j) = -Vy(j);
         <span class="keyword">end</span>
    <span class="keyword">end</span>

    Vx = Vx + Ex*C.q_0/C.m_0*dt; <span class="comment">% second term is acceleration x time</span>
    Vy = Vy + Ey*C.q_0/C.m_0*dt;

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% collision, mfp, and mean time between collisions tracking</span>
        <span class="keyword">if</span> (1-exp(-dt/taumn)) &gt; rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;

            Theta = rand(1, 1)*2*pi; <span class="comment">% rethermalizing after collision</span>
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    currentD(q) = 10^15*C.q_0*mean(Vx)*10^(-2); <span class="comment">% j-nev, 10^-2 is to convert everything to cm</span>

    pause(0.000001)

<span class="keyword">end</span>

figure(1) <span class="comment">% plotting current density vs time</span>
hold <span class="string">on</span>
plot(currentDTime(1:1000), currentD(1:1000))
title(<span class="string">'Current Density vs. Time'</span>);
hold <span class="string">off</span>

figure(3) <span class="comment">% plotting electron density map in a 50x50 grid</span>
hold <span class="string">on</span>
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title(<span class="string">'Electron Density Map'</span>);
hold <span class="string">off</span>

V5050 = zeros(50);

<span class="keyword">for</span> h=1:nElectrons <span class="comment">% calculating velocities for temperature calculation</span>
    <span class="keyword">for</span> i=1:50
        <span class="keyword">for</span> j=1:50
            <span class="keyword">if</span> x(h)&gt;((i-1)/50*L) &amp;&amp; x(h)&lt;(i/50*L) &amp;&amp; y(h)&gt;((j-1)/50*W) &amp;&amp; y(h)&lt;(j/50*W)
                V5050(i,j)=Vx(h)^2+Vy(h)^2;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">for</span> i=1:50 <span class="comment">% taking average velocity per cell</span>
    <span class="keyword">for</span> j=1:50
       <span class="keyword">if</span> n(i,j)~=0
          V5050(i,j) = V5050(i,j)/n(i,j);
       <span class="keyword">else</span>
          V5050(i,j) = 0;
       <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(4) <span class="comment">% plotting temperature density</span>
hold <span class="string">on</span>
m=V5050.*0.5*0.26*C.m_0/C.kb;
pcolor(m');
colorbar;
title(<span class="string">'Temperature Map'</span>);
hold <span class="string">off</span>
</pre><pre class="codeoutput">
avgV =

   2.0731e+05

</pre><img vspace="5" hspace="5" src="A3publish_01.png" alt=""> <img vspace="5" hspace="5" src="A3publish_02.png" alt=""> <img vspace="5" hspace="5" src="A3publish_03.png" alt=""> <img vspace="5" hspace="5" src="A3publish_04.png" alt=""> <h2>1 - Monte-Carlo Simluation Discussion<a name="2"></a></h2><p>1a) Since the electric field is just the voltage divided by the distance over which it is applied, the electric field for a 0.1V difference over a distance of 200nm would be 0.1V/200nm = 500,000V/m.</p><p>1b) The force on an electron is given by F = qE where q is the charge on the electron, and E is the electric field. For electrons in a 0.1V difference over a distance of 200nm, electrons would experience a force of F = (500,000V/m)(1.6 x 10^{-19}C) = 80 pN</p><p>1c) Done in code</p><p>1d) The relationship between electron drift current density and average carrier velocity is given by the equation j=nev, where j is the current density, n is the electron concentration, e is the elementary charge, and v is the average carrier velocity. The current plot is generated by the above code. As seen, the current density increases over time. This is due to the fact that the electrons are continually being sped up by the electric field and there is no boundary to slow them down.</p><p>1e) Done in code</p><h2>2 - Finite Difference Method<a name="3"></a></h2><p>Below is the code to calculate the electric field using the finite difference method.</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

L = 200;
W = 100;
Lb = 40;
Wb = 40;
Vo = 1;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

<span class="keyword">for</span> i=1:Wb
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i=round(W-Wb):W
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>

G = sparse(L*W,L*W);
B = zeros(1,L*W);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;

         <span class="keyword">if</span> j==1
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        <span class="keyword">elseif</span> j==L
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">elseif</span> i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1) + <span class="keyword">...</span>
                Sigma(i,j-1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j);
            G(n,n-1) = Sigma(i,j-1);
        <span class="keyword">elseif</span> i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + <span class="keyword">...</span>
                Sigma(i-1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">else</span>
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + <span class="keyword">...</span>
                Sigma(i-1,j) + Sigma(i+1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

F=G\B';

Vmap = zeros(W,L);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    <span class="keyword">end</span>
<span class="keyword">end</span>

figure(1)
hold <span class="string">on</span>
surf(Vmap);
title(<span class="string">'Voltage Distribution'</span>)
hold <span class="string">off</span>
pause(0.001);

[Ex,Ey]=gradient(-Vmap);

figure(2)
hold <span class="string">on</span>
quiver(Ex,Ey);
axis([0 L 0 W])
title(<span class="string">'Electric Field (V/m)'</span>)
hold <span class="string">off</span>
pause(0.001);
</pre><img vspace="5" hspace="5" src="A3publish_05.png" alt=""> <img vspace="5" hspace="5" src="A3publish_06.png" alt=""> <h2>3 - Combination<a name="4"></a></h2><p>Below is the code that implements the electron motion from part 1 under the influence of the electric field from part 2, with the bottle-neck included.</p><pre class="codeinput">clearvars
clearvars <span class="string">-GLOBAL</span>
close <span class="string">all</span>

L = 200;
W = 100;
Lb = 40;
Wb = 40;
Vo = 10;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

<span class="keyword">for</span> i=1:Wb
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i=round(W-Wb):W
    <span class="keyword">for</span> j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    <span class="keyword">end</span>
<span class="keyword">end</span>

G = sparse(L*W,L*W);
B = zeros(1,L*W);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;

         <span class="keyword">if</span> j==1
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        <span class="keyword">elseif</span> j==L
            G(n,:) = 0;
            G(n,n) = 1;
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">elseif</span> j==1 &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">elseif</span> j==L &amp;&amp; i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">elseif</span> i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1) + <span class="keyword">...</span>
                Sigma(i,j-1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j);
            G(n,n-1) = Sigma(i,j-1);
        <span class="keyword">elseif</span> i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + <span class="keyword">...</span>
                Sigma(i-1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
        <span class="keyword">else</span>
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + <span class="keyword">...</span>
                Sigma(i-1,j) + Sigma(i+1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j);
            G(n,n+L) = Sigma(i+1,j);
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

F=G\B';

Vmap = zeros(W,L);

<span class="keyword">for</span> i=1:W
    <span class="keyword">for</span> j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% figure(1)</span>
<span class="comment">% hold on</span>
<span class="comment">% surf(Vmap);</span>
<span class="comment">% title('Voltage Distribution')</span>
<span class="comment">% hold off</span>
<span class="comment">% pause(0.001);</span>

[Ex,Ey]=gradient(-Vmap);

<span class="comment">% figure(2)</span>
<span class="comment">% hold on</span>
<span class="comment">% quiver(Ex,Ey);</span>
<span class="comment">% axis([0 L 0 W])</span>
<span class="comment">% title('Electric Field (V/m)')</span>
<span class="comment">% hold off</span>
<span class="comment">% pause(0.001);</span>

Ex=Ex'/(1e-9);
Ey=Ey'/(1e-9);

<span class="comment">%%%%%%%%%%%%%%%%%%%%</span>

C.m_0 = 9.10938215e-31;             <span class="comment">% electron mass</span>
C.kb = 1.3806504e-23;               <span class="comment">% Boltzmann constant</span>
C.q_0 = 1.60217653e-19;             <span class="comment">% electron charge</span>

nElectrons = 10000;
nPlot=20; <span class="comment">% number of electrons to actually plot</span>
T = 300;
Lp = L*1e-9;
Wp = W*1e-9;
dt = 1e-15; <span class="comment">% since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s</span>
TStop = 1e-12; <span class="comment">% 1000 timesteps</span>
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); <span class="comment">% using 2 degrees of freedom</span>
time = 0;
Temp = T; <span class="comment">% temperature variable that updates in TempCalc</span>
taumn = 0.2e-12; <span class="comment">% average time between collisions</span>
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); <span class="comment">% standard deviation on vth</span>
cc = jet(nPlot); <span class="comment">% colorscale used to plot different electron colors</span>

collisionT = zeros(200,nElectrons); <span class="comment">% matrices for tracking collision time and velocities</span>
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*Lp; <span class="comment">% assigning random initial particle positions</span>
y = rand(1, nElectrons)*Wp;

<span class="keyword">for</span> i=1:nElectrons <span class="comment">% ensuring particles do not start in boxed boundaries</span>
   <span class="keyword">while</span>(1)
      <span class="keyword">if</span> ( x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7))
          x(i) = rand*Lp;
          y(i) = rand*Wp;
      <span class="keyword">else</span>
        <span class="keyword">break</span>
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

Theta = rand(1, nElectrons)*2*pi; <span class="comment">% selecting Vx and Vy from Gaussian centered at vth</span>
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons

figure(4)
hFig4 = figure(4);
set(hFig4, <span class="string">'Position'</span>, [200 0 900 1000])

hold <span class="string">on</span>
plot([0.8,0.8]*1e-7,[0,0.4]*1e-7, <span class="string">'r-'</span>)
plot([0.8,0.8]*1e-7,[0.6,1]*1e-7, <span class="string">'r-'</span>)
plot([1.2,1.2]*1e-7,[0,0.4]*1e-7, <span class="string">'r-'</span>)
plot([1.2,1.2]*1e-7,[0.6,1]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0,0]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0.4,0.4]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[0.6,0.6]*1e-7, <span class="string">'r-'</span>)
plot([0.8,1.2]*1e-7,[1,1]*1e-7, <span class="string">'r-'</span>)

axis([0 Lp 0 Wp]);

<span class="keyword">for</span> i=0:dt:TStop
    time = i;

    <span class="keyword">for</span> j=1:nPlot
        plot(x(j), y(j), <span class="string">'o'</span>,<span class="string">'markers'</span>, 1, <span class="string">'Color'</span>, cc(j,:));
    <span class="keyword">end</span>


    V2tot=Vx.*Vx+Vy.*Vy; <span class="comment">% calculated temp based on total velocities</span>
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;

    x = x - dt * Vx; <span class="comment">% moving the particles in one time step</span>
    y = y - dt * Vy;

    <span class="keyword">for</span> i=1:length(Vx)
        xE = round((x(i)*1e9+1)*200/201);
        yE = round((y(i)*1e9+1)*100/101);
        <span class="keyword">if</span> xE&gt;L
            xE=Lp;
        <span class="keyword">end</span>
        <span class="keyword">if</span> yE&gt;W
            yE=Wp;
        <span class="keyword">end</span>
        <span class="keyword">if</span> xE&lt;1
            xE=1;
        <span class="keyword">end</span>
        <span class="keyword">if</span> yE&lt;1
            yE=1;
        <span class="keyword">end</span>
        Vx(i) = Vx(i) + Ex(xE,yE)*C.q_0/C.m_0*dt;
        Vy(i) = Vy(i) + Ey(xE,yE)*C.q_0/C.m_0*dt;
    <span class="keyword">end</span>

    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% specular and periodic boundaries</span>
        <span class="keyword">if</span> x(j) &gt; Lp
            x(j) = x(j) - Lp;
        <span class="keyword">elseif</span> x(j) &lt; 0
            x(j) = x(j) + Lp;
        <span class="keyword">end</span>

         <span class="keyword">if</span> y(j) &gt; Wp
             Vy(j) = -Vy(j);
         <span class="keyword">elseif</span> y(j) &lt; 0
             Vy(j) = -Vy(j);
         <span class="keyword">end</span>
    <span class="keyword">end</span>



    <span class="keyword">for</span> j=1:nElectrons <span class="comment">% collision, mfp, and mean time between collisions tracking</span>
        <span class="keyword">if</span> (1-exp(-dt/taumn)) &gt; rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;

            Theta = rand(1, 1)*2*pi; <span class="comment">% rethermalizing after collision</span>
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> i=1:nElectrons <span class="comment">% conditions for meeting a boundary, specular reflection by inverting x or y velocity</span>
        <span class="keyword">if</span> Vy(i)&lt;0 &amp;&amp; y(i)&gt;0.6e-7 &amp;&amp; y(i)&lt;0.63e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7
            Vy(i)=-Vy(i);
        <span class="keyword">elseif</span> Vy(i)&gt;0 &amp;&amp; y(i)&lt;0.4e-7 &amp;&amp; y(i)&gt;0.37e-7 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;0.8e-7
            Vy(i)=-Vy(i);
        <span class="keyword">elseif</span> Vx(i)&lt;0 &amp;&amp; x(i)&gt;0.8e-7 &amp;&amp; x(i)&lt;0.85e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)
            Vx(i)=-Vx(i);
        <span class="keyword">elseif</span> Vx(i)&gt;0 &amp;&amp; x(i)&lt;1.2e-7 &amp;&amp; x(i)&gt;1.15e-7 &amp;&amp; (y(i)&lt;0.4e-7 || y(i)&gt;0.6e-7)
            Vx(i)=-Vx(i);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    pause(0.001)

<span class="keyword">end</span>

figure(5) <span class="comment">% plotting electron density map in a 50x50 grid</span>
hold <span class="string">on</span>
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title(<span class="string">'Electron Density Map'</span>);
hold <span class="string">off</span>
</pre><pre class="codeoutput">
avgV =

   2.0617e+05

</pre><img vspace="5" hspace="5" src="A3publish_07.png" alt=""> <img vspace="5" hspace="5" src="A3publish_08.png" alt=""> <h2>3 - Combination Discussion<a name="5"></a></h2><p>1a) Done in code</p><p>1b) As shown from the density plot, there are a large number of electrons collected on one side of the barrier. This is a result of the periodic boundary conditions that send electrons that go off the left side of the box into the right side of the box. If the electron goes through the gap with some y velocity, eventually after enough times of crossing the box it will end up blocked by the boundary. The random collisions add a layer of randomness to this process, so particles are also able to escape from being stuck on that side of the bottle-neck. However, as shown they tend to end up there more than anywhere else.</p><p>1c) Next steps to make this simulation more accurate would be to allow a certain amount of electrons with certain velocities to penetrate the bottle-neck based on the conductivity defined for that region. As the conductivity increases we expect that electrons would be able to pass through more easily, so defining this in-simluation would be useful.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ELEC 4700 Assignment 3 - Monte-Carlo/Finite Difference Method
%% 1 - Monte-Carlo Simluation
% Below is the code to simulate electron motion under the influence of an
% external electric field. 

C.m_0 = 9.10938215e-31;             % electron mass
C.kb = 1.3806504e-23;               % Boltzmann constant
C.q_0 = 1.60217653e-19;             % electron charge

nElectrons = 10000;
nPlot=20; % number of electrons to actually plot
T = 300;
L = 200e-9;
W = 100e-9;
dt = 1e-15; % since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s
TStop = 1e-12; % 1000 timesteps
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); % using 2 degrees of freedom
time = 0;
Temp = T; % temperature variable that updates in TempCalc
taumn = 0.2e-12; % average time between collisions
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); % standard deviation on vth
cc = jet(nPlot); % colorscale used to plot different electron colors

delVx = 0.8; % voltage difference in x direction
delVy = 0;

Ex = delVx/L;
Ey = delVy/W;

collisionT = zeros(200,nElectrons); % matrices for tracking collision time and velocities
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*L; % assigning random initial particle positions
y = rand(1, nElectrons)*W;

Theta = rand(1, nElectrons)*2*pi; % selecting Vx and Vy from Gaussian centered at vth
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons % calculation of initial average velocity

currentD = zeros(1,1000);
currentDTime = linspace(1,1000,1000);

figure(2)
hFig2 = figure(2);
set(hFig2, 'Position', [0 0 1200 1000])

q=0;

for i=0:dt:TStop
    time = i;
    q=q+1;

    hold on

    plot(x(1:30), y(1:30), 'bo','markers', 1);
    axis([0 L 0 W]);
    
    V2tot=Vx.*Vx+Vy.*Vy; % calculated temp based on total velocities
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;
    
    x = x - dt * Vx; % moving the particles in one time step
    y = y - dt * Vy;
    
    for j=1:nElectrons % specular and periodic boundaries
        if x(j) > L
            x(j) = x(j) - L;
        elseif x(j) < 0
            x(j) = x(j) + L;
        end
        
         if y(j) > W
             Vy(j) = -Vy(j);
         elseif y(j) < 0
             Vy(j) = -Vy(j);
         end
    end
    
    Vx = Vx + Ex*C.q_0/C.m_0*dt; % second term is acceleration x time
    Vy = Vy + Ey*C.q_0/C.m_0*dt;
    
    for j=1:nElectrons % collision, mfp, and mean time between collisions tracking
        if (1-exp(-dt/taumn)) > rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;
            
            Theta = rand(1, 1)*2*pi; % rethermalizing after collision
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        end
    end
    
    currentD(q) = 10^15*C.q_0*mean(Vx)*10^(-2); % j-nev, 10^-2 is to convert everything to cm
    
    pause(0.000001)
    
end

figure(1) % plotting current density vs time
hold on
plot(currentDTime(1:1000), currentD(1:1000))
title('Current Density vs. Time');
hold off

figure(3) % plotting electron density map in a 50x50 grid
hold on
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title('Electron Density Map');
hold off

V5050 = zeros(50);

for h=1:nElectrons % calculating velocities for temperature calculation
    for i=1:50
        for j=1:50
            if x(h)>((i-1)/50*L) && x(h)<(i/50*L) && y(h)>((j-1)/50*W) && y(h)<(j/50*W)
                V5050(i,j)=Vx(h)^2+Vy(h)^2;
            end
        end
    end
end

for i=1:50 % taking average velocity per cell
    for j=1:50
       if n(i,j)~=0
          V5050(i,j) = V5050(i,j)/n(i,j);  
       else
          V5050(i,j) = 0; 
       end
    end
end

figure(4) % plotting temperature density
hold on
m=V5050.*0.5*0.26*C.m_0/C.kb;
pcolor(m');
colorbar;
title('Temperature Map');
hold off

%% 1 - Monte-Carlo Simluation Discussion
% 1a) Since the electric field is just the voltage divided by the distance
% over which it is applied, the electric field for a 0.1V difference over a
% distance of 200nm would be 0.1V/200nm = 500,000V/m.
%
% 1b) The force on an electron is given by F = qE where q is the charge on
% the electron, and E is the electric field. For electrons in a 0.1V difference over a
% distance of 200nm, electrons would experience a force of F =
% (500,000V/m)(1.6 x 10^{-19}C) = 80 pN
%
% 1c) Done in code
%
% 1d) The relationship between electron drift current density and average
% carrier velocity is given by the equation j=nev, where j is the current
% density, n is the electron concentration, e is the elementary charge, and
% v is the average carrier velocity. The current plot is generated by the
% above code. As seen, the current density increases over time. This is due
% to the fact that the electrons are continually being sped up by the
% electric field and there is no boundary to slow them down. 
%
% 1e) Done in code
%% 2 - Finite Difference Method
% Below is the code to calculate the electric field using the finite
% difference method.

clearvars
clearvars -GLOBAL
close all

L = 200;
W = 100;
Lb = 40;
Wb = 40;
Vo = 1;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

for i=1:Wb
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end
for i=round(W-Wb):W
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end

G = sparse(L*W,L*W);
B = zeros(1,L*W);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        
         if j==1
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        elseif j==L
            G(n,:) = 0;
            G(n,n) = 1;
        elseif j==1 && i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j); 
        elseif j==L && i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+L) = Sigma(i+1,j);
        elseif j==1 && i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j); 
        elseif j==L && i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n-L) = Sigma(i-1,j);    
        elseif i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1) + ...
                Sigma(i,j-1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j); 
            G(n,n-1) = Sigma(i,j-1);
        elseif i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + ...
                Sigma(i-1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1); 
            G(n,n-L) = Sigma(i-1,j); 
        else
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + ...
                Sigma(i-1,j) + Sigma(i+1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1); 
            G(n,n-L) = Sigma(i-1,j); 
            G(n,n+L) = Sigma(i+1,j); 
        end
        
    end
end

F=G\B';

Vmap = zeros(W,L);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    end
end

figure(1)
hold on
surf(Vmap);
title('Voltage Distribution')
hold off
pause(0.001);

[Ex,Ey]=gradient(-Vmap);

figure(2)
hold on
quiver(Ex,Ey);
axis([0 L 0 W])
title('Electric Field (V/m)')
hold off
pause(0.001);

%% 3 - Combination
% Below is the code that implements the electron motion from part 1 under the influence
% of the electric field from part 2, with the bottle-neck included.

clearvars
clearvars -GLOBAL
close all

L = 200;
W = 100;
Lb = 40;
Wb = 40;
Vo = 10;
maxI = 200;
delta = 1;

Sigma = ones(W,L);

for i=1:Wb
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end
for i=round(W-Wb):W
    for j=round(L/2-Lb/2):round(L/2+Lb/2)
        Sigma(i,j) = 0.01;
    end
end

G = sparse(L*W,L*W);
B = zeros(1,L*W);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        
         if j==1
            G(n,:) = 0;
            G(n,n) = 1;
            B(n) = Vo;
        elseif j==L
            G(n,:) = 0;
            G(n,n) = 1;
        elseif j==1 && i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j); 
        elseif j==L && i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+L) = Sigma(i+1,j);
        elseif j==1 && i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j+1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n-L) = Sigma(i-1,j); 
        elseif j==L && i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i-1,j) + Sigma(i,j-1));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n-L) = Sigma(i-1,j);    
        elseif i==1
            G(n,:) = 0;
            G(n,n) = -(Sigma(i+1,j) + Sigma(i,j+1) + ...
                Sigma(i,j-1));
            G(n,n+1) = Sigma(i,j+1);
            G(n,n+L) = Sigma(i+1,j); 
            G(n,n-1) = Sigma(i,j-1);
        elseif i==W
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + ...
                Sigma(i-1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1); 
            G(n,n-L) = Sigma(i-1,j); 
        else
            G(n,:) = 0;
            G(n,n) = -(Sigma(i,j+1) + Sigma(i,j-1) + ...
                Sigma(i-1,j) + Sigma(i+1,j));
            G(n,n-1) = Sigma(i,j-1);
            G(n,n+1) = Sigma(i,j+1); 
            G(n,n-L) = Sigma(i-1,j); 
            G(n,n+L) = Sigma(i+1,j); 
        end
        
    end
end

F=G\B';

Vmap = zeros(W,L);

for i=1:W
    for j=1:L
        n = j + (i-1)*L;
        Vmap(i,j) = F(n);
    end
end

% figure(1)
% hold on
% surf(Vmap);
% title('Voltage Distribution')
% hold off
% pause(0.001);

[Ex,Ey]=gradient(-Vmap);

% figure(2)
% hold on
% quiver(Ex,Ey);
% axis([0 L 0 W])
% title('Electric Field (V/m)')
% hold off
% pause(0.001);

Ex=Ex'/(1e-9);
Ey=Ey'/(1e-9);

%%%%%%%%%%%%%%%%%%%%

C.m_0 = 9.10938215e-31;             % electron mass
C.kb = 1.3806504e-23;               % Boltzmann constant
C.q_0 = 1.60217653e-19;             % electron charge

nElectrons = 10000;
nPlot=20; % number of electrons to actually plot
T = 300;
Lp = L*1e-9;
Wp = W*1e-9;
dt = 1e-15; % since 1/100 of 200nm is 2nm, smallest step allowed is 2nm/vth ~= 1e-14s
TStop = 1e-12; % 1000 timesteps
Vth = sqrt(2*C.kb*T/(C.m_0*0.26)); % using 2 degrees of freedom
time = 0;
Temp = T; % temperature variable that updates in TempCalc
taumn = 0.2e-12; % average time between collisions
sigmaMB = sqrt(C.kb*T/(C.m_0*0.26)); % standard deviation on vth
cc = jet(nPlot); % colorscale used to plot different electron colors

collisionT = zeros(200,nElectrons); % matrices for tracking collision time and velocities
collisionV = zeros(200,nElectrons);
collisionIndex = ones(1,nElectrons);
collisions = 0;

x = rand(1, nElectrons)*Lp; % assigning random initial particle positions
y = rand(1, nElectrons)*Wp;

for i=1:nElectrons % ensuring particles do not start in boxed boundaries
   while(1) 
      if ( x(i)<1.2e-7 && x(i)>0.8e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)) 
          x(i) = rand*Lp;
          y(i) = rand*Wp;
      else
        break
      end
   end
end

Theta = rand(1, nElectrons)*2*pi; % selecting Vx and Vy from Gaussian centered at vth
Vx = cos(Theta).*(Vth + sigmaMB*randn(1, nElectrons));
Vy = sin(Theta).*(Vth + sigmaMB*randn(1, nElectrons));

avgV = sum(sqrt(Vx.^2+Vy.^2))/nElectrons

figure(4)
hFig4 = figure(4);
set(hFig4, 'Position', [200 0 900 1000])

hold on
plot([0.8,0.8]*1e-7,[0,0.4]*1e-7, 'r-')
plot([0.8,0.8]*1e-7,[0.6,1]*1e-7, 'r-')
plot([1.2,1.2]*1e-7,[0,0.4]*1e-7, 'r-')
plot([1.2,1.2]*1e-7,[0.6,1]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0,0]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0.4,0.4]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[0.6,0.6]*1e-7, 'r-')
plot([0.8,1.2]*1e-7,[1,1]*1e-7, 'r-')

axis([0 Lp 0 Wp]);

for i=0:dt:TStop
    time = i;
    
    for j=1:nPlot
        plot(x(j), y(j), 'o','markers', 1, 'Color', cc(j,:));
    end
    
    
    V2tot=Vx.*Vx+Vy.*Vy; % calculated temp based on total velocities
    KE = mean(V2tot)*0.5*(C.m_0*0.26);
    Temp = KE/C.kb;
    
    x = x - dt * Vx; % moving the particles in one time step
    y = y - dt * Vy;
    
    for i=1:length(Vx)
        xE = round((x(i)*1e9+1)*200/201);
        yE = round((y(i)*1e9+1)*100/101);
        if xE>L
            xE=Lp;
        end
        if yE>W
            yE=Wp;
        end
        if xE<1
            xE=1;
        end
        if yE<1
            yE=1;
        end
        Vx(i) = Vx(i) + Ex(xE,yE)*C.q_0/C.m_0*dt;
        Vy(i) = Vy(i) + Ey(xE,yE)*C.q_0/C.m_0*dt;     
    end
   
    for j=1:nElectrons % specular and periodic boundaries
        if x(j) > Lp
            x(j) = x(j) - Lp;
        elseif x(j) < 0
            x(j) = x(j) + Lp;
        end
        
         if y(j) > Wp
             Vy(j) = -Vy(j);
         elseif y(j) < 0
             Vy(j) = -Vy(j);
         end
    end
    

    
    for j=1:nElectrons % collision, mfp, and mean time between collisions tracking
        if (1-exp(-dt/taumn)) > rand()
            collisions = collisions+1;
            collisionT(collisionIndex(j)+1,j) = time;
            collisionV(collisionIndex(j)+1,j) = sqrt(Vx(j)^2+Vy(j)^2);
            collisionIndex(j)=collisionIndex(j)+1;
            
            Theta = rand(1, 1)*2*pi; % rethermalizing after collision
            Vx(j) = cos(Theta)*(Vth + sigmaMB*randn(1, 1));
            Vy(j) = sin(Theta)*(Vth + sigmaMB*randn(1, 1));
        end
    end
    
    for i=1:nElectrons % conditions for meeting a boundary, specular reflection by inverting x or y velocity
        if Vy(i)<0 && y(i)>0.6e-7 && y(i)<0.63e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
            Vy(i)=-Vy(i);
        elseif Vy(i)>0 && y(i)<0.4e-7 && y(i)>0.37e-7 && x(i)<1.2e-7 && x(i)>0.8e-7
            Vy(i)=-Vy(i);
        elseif Vx(i)<0 && x(i)>0.8e-7 && x(i)<0.85e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
            Vx(i)=-Vx(i);
        elseif Vx(i)>0 && x(i)<1.2e-7 && x(i)>1.15e-7 && (y(i)<0.4e-7 || y(i)>0.6e-7)
            Vx(i)=-Vx(i);
        end
    end

    pause(0.001)
    
end

figure(5) % plotting electron density map in a 50x50 grid
hold on
n=hist3([x',y'],[50 50]);
pcolor(n');
colorbar;
title('Electron Density Map');
hold off

%% 3 - Combination Discussion
% 1a) Done in code
%
% 1b) As shown from the density plot, there are a large number of electrons
% collected on one side of the barrier. This is a result of the periodic
% boundary conditions that send electrons that go off the left side of the
% box into the right side of the box. If the electron goes through the gap
% with some y velocity, eventually after enough times of crossing the box
% it will end up blocked by the boundary. The random collisions add a layer
% of randomness to this process, so particles are also able to escape from
% being stuck on that side of the bottle-neck. However, as shown they tend
% to end up there more than anywhere else.
%
% 1c) Next steps to make this simulation more accurate would be to allow a
% certain amount of electrons with certain velocities to penetrate the
% bottle-neck based on the conductivity defined for that region. As the
% conductivity increases we expect that electrons would be able to pass
% through more easily, so defining this in-simluation would be useful.
##### SOURCE END #####
--></body></html>